--- 
title: Neat Algorithms - Flocking
date: 03/02/2011

In this post I'll explain a neat and relatively well known algorithm that simulates a group of entities grouping together, illustrating something called "flocking". I think it's quite neat because the application of just a few simple governing rules to each entity results in a group which exhibits some collective intelligence, as well as complex and neat looking behaviour. The [original flocking algorithm][2] was developed by [Craig Reynolds][1] in 1986.

Flocking algorithms have some really neat real world applications:

 * Computer animation. [Batman Returns (1992)][3] is widely quoted as having been nominated for an Oscar for its bat swarms which were procedurally generated using algorithms similar to these.
 * Social network simulation and modeling opinion flow. After choosing humans as the entities in the flock, the overall direction of the flock can be estimated using the rules that apply to the simple flock model, and people's future opinions can be predicted. See [Gamasutra][4]'s stupendous article on the subject.
 * Aerospace engineering. By sending [UAV](http://en.wikipedia.org/wiki/Unmanned_aerial_vehicle)s on missions in flocks they are able to more effectively complete their missions and react to enemy events. See [one paper][5] and [another][6] on the subject.
 * Distributed systems analysis, search, and optimization. By modeling things like spacial data, network traffic, or solutions to an optimization problem as entities, the direction of the flock can be used to find [clusters][7], where to push traffic, or [optimal solutions][8].

## How it Works

Each entity on the map, which we'll now refer to as a "boid", is governed by a few simple rules. Each boid starts out at the center of the map with a random velocity, and for each frame of the simulation, a new velocity is calculated. The new velocity depends on the boid's current velocity, its neighbours' velocities, and its position relative to its neighbours. There are three components of the new velocity: the _alignment_, the _cohesion_, and the _separation_, which in combination simulate the full blown flocking behaviour.

## About this page

At any time you can click on any of the demos to stop or start the boid's movement. When the movement is stopped you can also hover your mouse over a boid to inspect the components of it's velocity generated by the flocking algorithm. Despite their tiny appearance they have a lot in common with elephants, including being afraid of mice! Feel free to perturb the flock using your mouse while the boids are moving, and watch them try and regroup.

All the demos are running the same algorithm, just with random start positions and random start velocities. The code running the actual demos can be found [here](https://github.com/hornairs/blog/tree/master/assets/coffeescripts/flocking). The running code as well as the examples are done in [Coffeescript](http://coffeescript.org/). If you haven't seen it before, it shouldn't be too hard to pick up, but visit that page if you want a quick primer on the syntax.

Here's the full algorithm in action:

<div class="flock" id="prettyDemo"></div>


### The code & components

Heres the essence of the Coffeescript class modeling the boid. Each boid has a `location`, and a `velocity`. Each frame calls the `step` method on each boid, which calculates an acceleration based on the 3 components. This acceleration is added to the velocity and limited so the boid can't go too fast. The new velocity is added to the location to actually move the boid.

    :::coffeescript
    # Ported almost directly from http://processingjs.org/learning/topic/flocking
    # thanks a whole lot to Craig Reynolds and Daniel Shiffman

    class Boid
      location: false
      velocity: false
      r: 3
      maxSpeed: 2
      maxForce: 0.05
      
      constructor: (loc, maxSpeed, maxForce) ->
        @velocity = new Vector(Math.random()*2-1,Math.random()*2-1)
        @location = loc.copy()
        [@maxSpeed, @maxForce] = [maxSpeed, maxForce]

      step: (neighbours) ->
        acceleration = this.flock(neighbours)
        @velocity.add(acceleration).limit(@max_speed)
        @location.add(@velocity)
        this._wrapIfNeeded()

      flock: (neighbours) ->
        separation = this.separate(neighbours).multiply(SEPARATION_WEIGHT)
        alignment = this.align(neighbours).multiply(ALIGNMENT_WEIGHT)
        cohesion = this.cohere(neighbours).multiply(COHESION_WEIGHT)
        return separation.add(alignment).add(cohesion)

### Cohesion

<div class="flock" id="cohesionDemo"></div>

Each boid tries to stay close to its neighbors, and the _cohesion_ component of the algorithm is mainly responsible for this. Every frame, each boid looks at the position of each other boid to see if it is within a specified `neighbour_radius`, that is, it checks to see which other boids are close enough to be considered flockmates. The positions of the qualifying neighbours are averaged and the boid steers to towards that position. This way, each boid is trying to steer towards the center of the flock, resulting in them all staying close together. 

The example on the right shows how the cohesion component of the algorithm works. The neighbour boids are drawn as green instead of blue when they are inside of the `neighbour_radius` of the pink boid. Their absolute locations are summed up (the dark purple vectors) to find the center of the flock. The light pink vector points to the center point. The blue vector shows the path by which the boid decides to steer towards the center point at the end of the light pink vector.

Also note that if a boid has only one neighbour, the center of its neighbouring flock is exactly its neighbour's location, so the dark purple and light purple vectors point to the same position.

#### Code

The cohesion component is calculated by averaging the location of all the neighbours within the `NEIGHBOUR_RADIUS`. Note that the returned value is the result of calling `steer_to` on the average position. The `steer_to` method implements some basic easing towards a target so the boids turn towards fellow flock members at reasonable speeds instead of instantly switching direction.

    :::coffeescript
    class Boid
      cohere: (neighbours) ->
        sum = new Vector
        count = 0
        for boid in neighbours
          d = @location.distance(boid.location)
          if d > 0 and d < NEIGHBOUR_RADIUS
            sum.add(boid.location)
            count++

        if count > 0
          return this.steer_to sum.divide(count)
        else
          return sum # Empty vector contributes nothing

      steer_to: (target) ->
        desired = Vector.subtract(target, @location) # A vector pointing from the location to the target
        d = desired.magnitude()  # Distance from the target is the magnitude of the vector

        # If the distance is greater than 0, calc steering (otherwise return zero vector)
        if d > 0
          desired.normalize()

          # Two options for desired vector magnitude (1 -- based on distance, 2 -- maxspeed)
          if d < 100.0
            desired.multiply(MAX_SPEED*(d/100.0)) # This damping is somewhat arbitrary
          else
            desired.multiply(MAX_SPEED)
          
          # Steering = Desired minus Velocity
          steer = desired.subtract(@velocity)
          steer.limit(MAX_FORCE)  # Limit to maximum steering force
        else
          steer = new Vector(0,0)

        return steer

### Alignment

<div class="flock" id="alignmentDemo"></div>

Each boid in a flock tries to stay in line with rest of the flock, which is the responsibility of the _alignment_ portion of the algorithm. Each frame, each boid looks at the heading in which it is travelling in comparison to the headings of all its neighbours, and realigns itself to match their heading. The velocity vectors of each boid within the `neighbour_radius` are averaged and the resulting vector is mixed in with the other components of the algorithm to find the boid's final acceleration for the frame.

In the example on the left, the neighbouring boids are highlighted in green, and their velocities are shown in light green. Each of those velocities is averaged to find the average heading the pink boid should head in. This new heading is shown as the bright green vector coming from the pink boid. You can also see the pink boid's velocity as the black vector, and notice how if the angle between the current velocity in black and the average alignment of the neighbours in bright green is large, it gradually decreases as the boid adopts the new heading.

#### Code

The alignment is calculated by averaging the velocities of the neighbours within the `NEIGHBOUR_RADIUS`. The return value is also `limited` to exert upto the maximium force. This is so that the alignment component can't overpower the others, which can happen if there is a big difference between the current boid and its neighbours' velocities.

    :::coffeescript
    class Boid
      align: (neighbours) ->
        mean = new Vector
        count = 0
        for boid in neighbours
          d = @location.distance(boid.location)
          if d > 0 and d < NEIGHBOUR_RADIUS
            mean.add(boid.velocity)
            count++

        mean.divide(count) if count > 0
        mean.limit(MAX_FORCE)
        return mean
    
### Separation

<div class="flock" id="separationDemo"></div>

While in a flock each boid tries not to run into all the other ones. They try to remain _separate_ by keeping a specified amount of space in between themselves. Each boid checks all the other boids on the map to see if the distance between them is too small, and if so, adds an inversely proportional amount to its velocity in the opposite direction.

In the example on the right you can see the red circle which indicates the desired separation around the pink boid. If a boid enters this radius, the pink boid tries to navigate away. Boids which violate the pink boid's desired separation are also highlighted in red. The red arrow pointing out of the pink boid is the separation component of the algorithm, pointing away from any boids that are too close. Note that right at the start, all the boids are too close to the pink one, so they are all highlighted in red. 

### Bringing it all together

## Code

Heres the essence of the Coffeescript class for the 
    :::coffeescript
    # Ported almost directly from http://processingjs.org/learning/topic/flocking
    # thanks to Craig Reynolds and Daniel Shiffman
    # 
    SEPARATION_WEIGHT = 2
    ALIGNMENT_WEIGHT = 1
    COHESION_WEIGHT = 1

    DESIRED_SEPARATION = 18
    NEIGHBOUR_RADIUS = 50

    class Harry.Boid
      location: false
      velocity: false
      r: 3
      maxSpeed: 0
      maxForce: 0
      
      constructor: (loc, maxSpeed, maxForce) ->
        @velocity = new Vector(Math.random()*2-1,Math.random()*2-1)
        @location = loc.copy()
        [@maxSpeed, @maxForce] = [maxSpeed, maxForce]

      move: (acceleration) ->
        @velocity.add(acceleration).limit(@max_speed)
        @location.add(@velocity)
        this._wrapIfNeeded()

      flock: (neighbours) ->
        separation = this._separate(neighbours).multiply(SEPARATION_WEIGHT)
        alignment = this._align(neighbours).multiply(ALIGNMENT_WEIGHT)
        cohesion = this._cohesion(neighbours).multiply(COHESION_WEIGHT)
        return separation.add(alignment).add(cohesion)

      separate: (neighbours) ->
        mean = new Harry.Vector
        count = 0
        for boid in neighbours
          continue if boid == this
          d = @location.distance(boid.location)
          if d > 0 and d < DESIRED_SEPARATION
            mean.add Harry.Vector.subtract(@location,boid.location).normalize().divide(d) # Normalized,weighted by distance vector pointing away from the neighbour
            count++

        mean.divide(count) if count > 0
        mean

      align: (neighbours) ->
        mean = new Harry.Vector
        count = 0
        for boid in neighbours
          continue if boid == this
          d = @location.distance(boid.location)
          if d > 0 and d < NEIGHBOUR_RADIUS
            mean.add(boid.velocity)
            count++

        mean.divide(count) if count > 0
        mean.limit(@max_force)
        mean

      cohesion: (neighbours) ->
        sum = new Harry.Vector
        count = 0
        for boid in neighbours
          continue if boid == this
          d = @location.distance(boid.location)
          if d > 0 and d < NEIGHBOUR_RADIUS
            sum.add(boid.location)
            count++

        if count > 0
          this.steer_to sum.divide(count)
        else
          sum

      steer_to: (target) ->
        desired = Harry.Vector.subtract(target, @location) # A vector pointing from the location to the target  
        d = desired.magnitude()  # Distance from the target is the magnitude of the vector  
        # If the distance is greater than 0, calc steering (otherwise return zero vector)  
        if d > 0
          # Normalize desired  
          desired.normalize()
          # Two options for desired vector magnitude (1 -- based on distance, 2 -- maxspeed)  
          if d < 100.0
            desired.multiply(@max_speed*(d/100.0)) # This damping is somewhat arbitrary  
          else
            desired.multiply(@max_speed)
            # Steering = Desired minus Velocity
          steer = desired.subtract(desired,@velocity)
          steer.limit(@max_force)  # Limit to maximum steering force
        else
          steer = new Harry.Vector(0,0)
        return steer
       

<script type="text/javascript">
  var Harry = {};
</script>

<script src="/js/processing.js" type="text/javascript"></script>
<script src="/js/flocking/vector.js" type="text/javascript"></script>
<script src="/js/flocking/boid.js" type="text/javascript"></script>
<script src="/js/flocking/flock.js" type="text/javascript"></script>
<script src="/js/flocking/flocking.js" type="text/javascript"></script>
<link href='/css/flocking.css' rel='stylesheet' type='text/css' /> 

[1]: http://www.red3d.com/cwr/index.html "Craig Reynold's personal site"
[2]: http://www.red3d.com/cwr/boids/ "Craig Reynold's site on Boids & Flocking"
[3]: http://www.imdb.com/title/tt0103776/awards "Batman Returns (1992) Awards list"
[4]: http://www.gamasutra.com/view/feature/1815/modeling_opinion_flow_in_humans_.php "Modeling opinion flow using Boid algorithms at Gamasutra"
[5]: http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=1470734 "Paper from the ACC in 2005 describing the performance of UAV flock missions"
[6]: http://ieeexplore.ieee.org/Xplore/login.jsp?url=http://ieeexplore.ieee.org/iel5/5351161/5356514/05356552.pdf%3Farnumber%3D5356552&authDecision=-203 "Paper from the ACC in 2005 describing the performance of UAV flock missions"
[7]: http://www.springerlink.com/content/c7t0fb6a54flkrw8/ "Paper on performant parallel spacial clustering from 2002"
[8]: http://www.engr.iupui.edu/~shi/pso.html "Page on particle swarm optimization with references."
